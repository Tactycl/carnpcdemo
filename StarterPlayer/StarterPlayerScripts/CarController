-- Services

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local HapticService = game:GetService("HapticService")

-- Variables

local LocalPlayer = Players.LocalPlayer
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")

local Vehicles = workspace:WaitForChild("Vehicles")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local Modules = ReplicatedStorage:WaitForChild("Modules")

local GameSettings = require(ReplicatedStorage.Modules.GameSettings)
local CarClient = require(Modules:WaitForChild("CarClient"))
local renderSetUps = {}

local currentCarPhysics = nil
local lastBaseAngularX, lastBaseAngularY = 0, 0
local camGoalX, camGoalY = 0, 0
local camX, camY = 0, 0

local CAM_FREE_SPACE = 0.2
local MOUSE_SENSITIVITY = .025
local camera = workspace.CurrentCamera
local cameraParams = RaycastParams.new()
cameraParams.CollisionGroup = "Default"
cameraParams.FilterDescendantsInstances = {Vehicles, workspace:WaitForChild("NPCContainer")}
cameraParams.FilterType = Enum.RaycastFilterType.Exclude
cameraParams.IgnoreWater = true
cameraParams.RespectCanCollide = true

-- Runtime

-- Roblox :Lerp but for numbers
function lerp(a, b, t)
	return a + (b - a) * t
end

-- finds player vehicle by going through all cars and looking if the seat's occupant is the player's humanoid
function FindVehicle(player)
	if player == nil or player.Character == nil or player.Character:FindFirstChild("Humanoid") == nil then return end

	for _, vehicle in Vehicles:GetChildren() do
		if not vehicle:FindFirstChild("Base") or not vehicle.Base:FindFirstChild("Seat") then vehicle:Destroy() continue end
		local seat = vehicle.Base.Seat
		if seat.Occupant ~= player.Character.Humanoid then continue end
		
		return vehicle
	end
end

-- is being called later in the script whenever the player sits down, checks if it's a car and then inits the new car physics and removes an old one (if exists)
function onSeated(isSeated, seat)
	local isCarSeat = seat and seat.Parent.Name == "Base" and seat:IsDescendantOf(Vehicles)

	if currentCarPhysics then currentCarPhysics:remove() currentCarPhysics = nil end
	if isSeated and isCarSeat then
		currentCarPhysics = CarClient.init(seat.Parent.Parent)
		camera.CameraType = Enum.CameraType.Scriptable

	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true

		camera.CameraType = Enum.CameraType.Custom
	end
end

-- always fires when player has a character added (used for firing/setting up onSeated)
function CharacterAdded(char)
	Character = char
	Humanoid = char:WaitForChild("Humanoid") :: Humanoid

	if Humanoid.SeatPart ~= nil then onSeated(true, Humanoid.SeatPart) end
	Humanoid:GetPropertyChangedSignal("SeatPart"):Connect(function()
		onSeated(true, Humanoid.SeatPart)
	end)
end

-- Gets computer steering by the A and D keys (-1 to 1)
function getComputerSteer()
	return (UserInputService:IsKeyDown(Enum.KeyCode.D) and 1 or 0) - (UserInputService:IsKeyDown(Enum.KeyCode.A) and 1 or 0)
end

-- if angle > math.pi (180°) it wraps around to -180°, same for the opposite.
function adjustAngleWraparound(angle)
	if angle > math.pi then
		return angle - (2 * math.pi)
	elseif angle < -math.pi then
		return angle + (2 * math.pi)
	end
	return angle
end

--[[
clamps camera X (vertical) by -70 and 20 degrees.
It does the angle wrap around but with two variables being set inside.
It changes the X and Y angle with a "lerp" where you could really use the lerp function, I don't know why I didn't. But it changes your camera with 3 * deltaTime as the alpha.
It finds your current camera and if it isn't a free moving camera it's locked. If MB2 is pressed you move your camera around, it locks your cursor too.
At the bottom it just sets the new CFRAME and does a raycast so your camera doesn't go through the wall.
]]
function updateCamera(delta)
	local alpha = 3 * delta

	camGoalX = math.clamp(camGoalX, math.rad(-70), math.rad(20))

	if camGoalY > math.pi then
		camGoalY -= 2 * math.pi
		camY -= 2 * math.pi
	elseif camGoalY < -math.pi then
		camGoalY += 2 * math.pi
		camY += 2 * math.pi
	end

	camX = camX + (camGoalX - camX) * alpha
	camY = camY + (camGoalY - camY) * alpha

	local cam = currentCarPhysics.Vehicle.Base.Base.Cameras:FindFirstChild(currentCarPhysics.currentCamera)
	if not cam then return end

	if not cam:GetAttribute("Free") then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true

		camera.CFrame = cam.WorldCFrame
		return
	end

	local BaseAngularX, BaseAngularY = currentCarPhysics.Vehicle.Base.Base.CFrame:ToOrientation()
	if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		UserInputService.MouseIconEnabled = false

		local mouseDelta = UserInputService:GetMouseDelta()
		local xdiff, ydiff = (BaseAngularX - lastBaseAngularX), (BaseAngularY - lastBaseAngularY)

		camGoalX += adjustAngleWraparound(xdiff) - (mouseDelta.Y * MOUSE_SENSITIVITY * (GameSettings["Sensitivity"] / 100))
		camGoalY += adjustAngleWraparound(ydiff) - (mouseDelta.X * MOUSE_SENSITIVITY * (GameSettings["Sensitivity"] / 100))

	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true

		camGoalX, camGoalY = currentCarPhysics.Vehicle.Base.Base.CFrame:ToOrientation()
		local diffy = (camGoalY - camY)
		if diffy > math.pi then
			camGoalY -= 2 * math.pi

		elseif diffy < -math.pi then
			camGoalY += 2 * math.pi
		end
	end

	local newCameraCFrame = (CFrame.fromOrientation(camX, camY, 0) * cam.CFrame + currentCarPhysics.Vehicle.Base.Base.Position) - currentCarPhysics.Vehicle.Base.Base.AssemblyLinearVelocity / 25
	local origin = currentCarPhysics.Vehicle.Base.Base.Position
	local goalPosition = newCameraCFrame.Position + newCameraCFrame.Position.Unit * CAM_FREE_SPACE
	local raycast = workspace:Raycast(origin, (goalPosition - origin), cameraParams)

	if raycast and not raycast.Instance:IsDescendantOf(Character) then
		newCameraCFrame += -newCameraCFrame.Position + raycast.Position + raycast.Normal * CAM_FREE_SPACE
	end

	camera.CFrame = newCameraCFrame
	lastBaseAngularX, lastBaseAngularY = BaseAngularX, BaseAngularY
end

-- Gets the gears "Name" from the current physics for the GUI
function getGearDefinition()
	if currentCarPhysics.parked then return "P" end
	if currentCarPhysics.currentGear == -1 then return "R" end
	if currentCarPhysics.currentGear == 0 then return "N" end
	if currentCarPhysics.config.AUTOMATIC then return "A" .. currentCarPhysics.currentGear end
	return "M" .. currentCarPhysics.currentGear
end

-- updates the GUI every frame like the gear "Name" with getGearDefinition and the RPM meter
function updateUI(delta)
	local delta60 = delta * 60
	local goalRotation = lerp(currentCarPhysics.UI_START_ROTATION, currentCarPhysics.UI_END_ROTATION, currentCarPhysics.currentRPM / (currentCarPhysics.UI_RPM_ITEMS * 1000))

	currentCarPhysics.UI.Main.Circle.Gear.Text = getGearDefinition()
	currentCarPhysics.UI.Main.Display.Rotation = lerp(currentCarPhysics.UI.Main.Display.Rotation, goalRotation, .9 * delta60)

	local speed = math.round(currentCarPhysics.currentSpeed)
	local splitSpeed = string.split(tostring(speed), "")

	currentCarPhysics.UI.Main.Speed1.TextTransparency = speed >= 100 and 0 or .5
	currentCarPhysics.UI.Main.Speed2.TextTransparency = speed >= 10 and 0 or .5
	currentCarPhysics.UI.Main.Speed3.TextTransparency = speed > 0 and 0 or .5
	currentCarPhysics.UI.Main.Speed1.Text = splitSpeed[#splitSpeed - 2] or "0"
	currentCarPhysics.UI.Main.Speed2.Text = splitSpeed[#splitSpeed - 1] or "0"
	currentCarPhysics.UI.Main.Speed3.Text = splitSpeed[#splitSpeed] or "0"
end

-- renders visuals of a car, here it is the "Fixed" stuff, which are the wheel's brake for example
function initRender(car)

	renderSetUps[car] = {
		RunService.Heartbeat:Connect(function(delta)
			local success, errorMessage = pcall(function()
				for _, wheel in car.Base.Wheels:GetChildren() do
					if not wheel:IsA("BasePart") then continue end

					local correspondingAttachment = car.Base.Base:FindFirstChild(wheel.Name)
					local FixedAttachment = car.Base.Base:FindFirstChild("FixedAttachment" .. wheel.Name)
					if not correspondingAttachment or not FixedAttachment then continue end

					local aX, aY, aZ = correspondingAttachment.WorldCFrame:ToOrientation()
					FixedAttachment.WorldCFrame = CFrame.new(wheel.Attachment.WorldPosition) * CFrame.fromOrientation(aX, aY, aZ)
				end
			end)
			if not success then
				print("Disconnecting car rendering from", car.Name)
				removeRender(car)
			end
		end),
		
		CarClient.initVisuals(car),
	}
end

-- removes a set up renderer (initRender) for cars being removed
function removeRender(car)
	if renderSetUps[car] then
		renderSetUps[car][1]:Disconnect()
		renderSetUps[car][2]:removeVisuals()
		renderSetUps[car] = nil
	end
end

-- inits all existing cars if player joins late
for _, vehicle in Vehicles:GetChildren() do
	initRender(vehicle)
end

--[[
long script, more comments inside of it. Basically it detects input for computer and sets gas or brake to 1, uses getComputerSteer twice for when you press A or D.
For gamepad it uses the thumbstick1 X position for steer.
When the car is NOT automatic and you press the gear down or gear up button specified in your settings which you open with TAB, it gets the new GEAR ID and sets it.
For GEAR UP it also does a random amount of backfire.
"C" changes the camera in the current car client up by 1 and wraps back to 1 when you're above all camera ids. For example: you have 2 cameras, it goes 1, 2, 1 ...
The flip car button specified in settings just adds some body force objects to get the car back on its wheels.
]]

local flipDebounce = false
UserInputService.InputBegan:Connect(function(inp, gpe)
	if gpe and inp.UserInputType ~= Enum.UserInputType.Gamepad1 then return end

	if currentCarPhysics then
		if inp.KeyCode == Enum.KeyCode.W or inp.KeyCode == Enum.KeyCode.ButtonR2 then
			currentCarPhysics.gas = 1

		elseif inp.KeyCode == Enum.KeyCode.S or inp.KeyCode == Enum.KeyCode.ButtonL2 then
			currentCarPhysics.brake = 1

		elseif inp.KeyCode == Enum.KeyCode.A then
			currentCarPhysics.steer = getComputerSteer()

		elseif inp.KeyCode == Enum.KeyCode.D then
			currentCarPhysics.steer = getComputerSteer()
			
		elseif inp.KeyCode == Enum.KeyCode.P and math.abs(currentCarPhysics.currentSpeed) < 5 then
			currentCarPhysics.parked = not currentCarPhysics.parked

		elseif inp.KeyCode == Enum.KeyCode.Thumbstick1 then
			currentCarPhysics.steer = inp.Position.X

		elseif not currentCarPhysics.config.AUTOMATIC and (inp.KeyCode == GameSettings["Shift Down"] or inp.KeyCode == Enum.KeyCode.ButtonX) and currentCarPhysics.currentGear ~= 0 then
			local curGear = currentCarPhysics.currentGear
			local nextGear = math.clamp(curGear - 1, -1, #currentCarPhysics.config.GEAR_RATIOS - 1)
			nextGear = nextGear == 0 and -1 or nextGear

			if currentCarPhysics.currentGear ~= nextGear then
				currentCarPhysics.currentGear = 0
				task.wait(currentCarPhysics.config.MANUAL_GEAR_CHANGE_TIME)
				
				currentCarPhysics.currentGear = nextGear
			end

		elseif not currentCarPhysics.config.AUTOMATIC and (inp.KeyCode == GameSettings["Shift Up"] or inp.KeyCode == Enum.KeyCode.ButtonY) and currentCarPhysics.currentGear ~= 0 then
			local curGear = currentCarPhysics.currentGear
			local nextGear = math.clamp(curGear + 1, -1, #currentCarPhysics.config.GEAR_RATIOS - 1)
			nextGear = nextGear == 0 and 1 or nextGear
			if currentCarPhysics.currentGear ~= nextGear then
				currentCarPhysics.currentGear = 0
				task.wait(currentCarPhysics.config.MANUAL_GEAR_CHANGE_TIME)
				
				currentCarPhysics.currentGear = nextGear
				
				local amountBackfire = math.random(1, 100) <= 50 and (math.random(1, 100) <= 50 and 2 or 1) or 0
				task.spawn(function()
					for i = 1, amountBackfire, 1 do
						currentCarPhysics:Backfire(currentCarPhysics.Vehicle)
						task.wait(.2)
					end
				end)
			end

		elseif inp.KeyCode == Enum.KeyCode.C or inp.KeyCode == Enum.KeyCode.ButtonR1 then
			currentCarPhysics.currentCamera = currentCarPhysics.currentCamera % #currentCarPhysics.Vehicle.Base.Base.Cameras:GetChildren() + 1

		elseif inp.KeyCode == GameSettings["Handbrake"] or inp.KeyCode == Enum.KeyCode.ButtonB then
			currentCarPhysics.handbrake = true

		elseif inp.KeyCode == GameSettings["Flip Car"] or inp.KeyCode == Enum.KeyCode.ButtonA then
			if currentCarPhysics.Vehicle.Base.Base.AssemblyLinearVelocity.Magnitude <= 5 and not flipDebounce then
				flipDebounce = true

				local bodyPosition = Instance.new("BodyPosition", currentCarPhysics.Vehicle.Base.Base)
				bodyPosition.Position = currentCarPhysics.Vehicle.Base.Base.Position + Vector3.yAxis * 10
				bodyPosition.MaxForce = Vector3.one * 99999
				bodyPosition.P = 99999
				bodyPosition.D = 2500

				local _, gyroY = currentCarPhysics.Vehicle.Base.Base.CFrame:ToOrientation()

				local bodyGyro = Instance.new("BodyGyro", currentCarPhysics.Vehicle.Base.Base)
				bodyGyro.CFrame = CFrame.fromOrientation(0, gyroY, 0)
				bodyGyro.MaxTorque = Vector3.one * 99999
				bodyGyro.P = 99999
				bodyGyro.D = 2500

				task.wait(1.5)

				bodyPosition:Destroy()
				bodyGyro:Destroy()

				task.wait(1.5)

				flipDebounce = false
			end
		end
	end
end)

-- detects whenever you stop pressing a button to stop the gas, brake, steer and handbrake
UserInputService.InputEnded:Connect(function(inp, gpe)
	if gpe and inp.UserInputType ~= Enum.UserInputType.Gamepad1 then return end

	if currentCarPhysics then
		if inp.KeyCode == Enum.KeyCode.W or inp.KeyCode == Enum.KeyCode.ButtonR2 then
			currentCarPhysics.gas = 0

		elseif inp.KeyCode == Enum.KeyCode.S or inp.KeyCode == Enum.KeyCode.ButtonL2 then
			currentCarPhysics.brake = 0

		elseif inp.KeyCode == Enum.KeyCode.A then
			currentCarPhysics.steer = getComputerSteer()

		elseif inp.KeyCode == Enum.KeyCode.D then
			currentCarPhysics.steer = getComputerSteer()

		elseif inp.KeyCode == Enum.KeyCode.Thumbstick1 then
			currentCarPhysics.steer = 0

		elseif inp.KeyCode == GameSettings["Handbrake"] or inp.KeyCode == Enum.KeyCode.ButtonB then
			currentCarPhysics.handbrake = false
		end
	end
end)

-- basically just detects when the Triggers or Thumbsticks of a controller change input, used for steering, gas and brake
UserInputService.InputChanged:Connect(function(inp, gpe)
	if gpe and inp.UserInputType ~= Enum.UserInputType.Gamepad1 then return end

	if currentCarPhysics then
		if inp.KeyCode == Enum.KeyCode.ButtonR2 then
			currentCarPhysics.gas = inp.Position.Z

		elseif inp.KeyCode == Enum.KeyCode.ButtonL2 then
			currentCarPhysics.brake = inp.Position.Z

		elseif inp.KeyCode == Enum.KeyCode.Thumbstick1 then
			currentCarPhysics.steer = inp.Position.X
		end
	end
end)

-- runs every frame, checks if you have a car and the model of the car isn't nil (nothing), sets all haptic motors of a controller, updates the camera with a function and the GUI
RunService.RenderStepped:Connect(function(delta)
	if not currentCarPhysics then return end
	if currentCarPhysics.Vehicle == nil then currentCarPhysics = nil return end

	HapticService:SetMotor(Enum.UserInputType.Gamepad1, Enum.VibrationMotor.Large, math.clamp(currentCarPhysics.avgSlip / 20, 0, 1))
	HapticService:SetMotor(Enum.UserInputType.Gamepad1, Enum.VibrationMotor.Small, math.clamp((currentCarPhysics.currentRPM - currentCarPhysics.previousRPM) / 400, 0, 1))
	updateCamera(delta)
	updateUI(delta)
end)

-- some basic RBXScriptSignals
Vehicles.ChildAdded:Connect(initRender)
Vehicles.ChildRemoved:Connect(removeRender)
LocalPlayer.CharacterAdded:Connect(CharacterAdded)

-- This is used, since the car is on the client, for multiplayer lights, so others can see your lights. Which is also why "doesSendServer" here is false
Remotes.CarLights.OnClientEvent:Connect(function(userid, lightName, lightActive)
	local player = Players:GetPlayerByUserId(userid)
	local vehicle = FindVehicle(player)
	if not vehicle then return end
	
	CarClient:SetLights(vehicle, lightName, lightActive, false)
end)

-- This, similar to CarLights, is sent for multiplayer backfire
Remotes.CarBackfire.OnClientEvent:Connect(function(userid)
	local player = Players:GetPlayerByUserId(userid)
	local vehicle = FindVehicle(player)
	if not vehicle then return end
	
	CarClient:Backfire(vehicle, false)
end)

-- At the top it already waits if there is no character so CharacterAdded won't be fired, which is why we do this single call.
CharacterAdded(Character)
