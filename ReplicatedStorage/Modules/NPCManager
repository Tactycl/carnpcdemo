-- Services

local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Classes

type NPC = {
	model: Model,
	NPCtype: "Pedestrian" | "Car",
	state: "Wandering" | "Dead" | "Ragdolled",
	offset: Vector3,
	loadedAnim: AnimationTrack,
	dodgeRadius: number,
	active: boolean,
	moving: boolean,
	walkSpeed: number,
	normalWalkSpeed: number,
	previousNode: number,
	currentNode: number,
	currentPath: {number},
	goalNode: number,
	deathByCarSignal: RBXScriptSignal,
}

type Node = {
	position: Vector3,
	accessible: "Pedestrian" | "Car",
	nodetype: "Crosswalk" | "Sidewalk",
	connectedids: {number},
}

type Manager = {
	NPCs: {NPC},
	Cars: {Model},
	Nodes: {number: Node},
	streamingRadius: number,
	overlapParams: OverlapParams,
}

-- Variables

local gyroMaxTorque = 9999
local minwalkspeed, maxwalkspeed = 9, 22
local random = Random.new()

local disabledStates = {
	Enum.HumanoidStateType.Climbing,
	Enum.HumanoidStateType.Flying,
	Enum.HumanoidStateType.Jumping,
	Enum.HumanoidStateType.Physics,
	--Enum.HumanoidStateType.Ragdoll,
	Enum.HumanoidStateType.RunningNoPhysics,
	Enum.HumanoidStateType.Seated,
	Enum.HumanoidStateType.StrafingNoPhysics,
	Enum.HumanoidStateType.Swimming,
}

local Vehicles = workspace:WaitForChild("Vehicles")
local Folder = workspace:FindFirstChild("NPCContainer") or Instance.new("Folder", workspace)
Folder.Name = "NPCContainer"

local tempFolder = ReplicatedStorage:FindFirstChild("TempNPCContainer") or Instance.new("Folder", ReplicatedStorage)
tempFolder.Name = "TempNPCContainer"

local manager = {}
manager.__index = manager

-- Runtime

function manager.new()
	local self = setmetatable({} :: Manager, manager)

	self.streamingRadius = 100
	self.NPCs = {}
	self.Cars = Vehicles:GetChildren()
	self.Nodes = {}
	self.overlapParams = OverlapParams.new()
	self.overlapParams.FilterDescendantsInstances = {Folder, Vehicles}
	self.overlapParams.FilterType = Enum.RaycastFilterType.Include
	self.overlapParams.CollisionGroup = "NPC"

	Vehicles.ChildAdded:Connect(function(child)
		table.insert(self.Cars, child)
	end)

	Vehicles.ChildRemoved:Connect(function(child)
		local found = table.find(self.Cars, child)
		if not found then return end
		table.remove(self.Cars, found)
	end)

	print("init new npc manager on client")
	return self
end

function manager:addNPC(model, npcType, startingNode)
	if not model.PrimaryPart then print("Couldn't add NPC because no primary part added.") return end
	if not startingNode then
		local accessibleNodes = {}

		for id, nodeData in self.Nodes do
			if nodeData.accessible ~= npcType then continue end
			table.insert(accessibleNodes, id)
		end
		if #accessibleNodes == 0 then
			print("failed to add npc of", npcType, "type to manager because no accessible node found") 
			return
		end

		startingNode = math.random(1, #accessibleNodes)
	end

	local physicalProperties = PhysicalProperties.new(7, 1, 1, 20, 1)
	for _, obj in model:GetDescendants() do
		if not obj:IsA("BasePart") then continue end
		obj.CollisionGroup = "NPC"
		obj.CustomPhysicalProperties = physicalProperties
	end

	for _, state in disabledStates do
		model.Humanoid:SetStateEnabled(state, false)
	end

	local gyro = Instance.new("BodyGyro", model.PrimaryPart)
	gyro.P = 50000
	gyro.D = 1000
	gyro.CFrame = CFrame.identity
	gyro.MaxTorque = Vector3.yAxis * gyroMaxTorque
	gyro.Name = "TurningGyro"

	local extentsCFrame, extentsSize = model:GetBoundingBox()
	local modelHitbox = Instance.new("Part", model)
	modelHitbox.CFrame = extentsCFrame
	modelHitbox.Size = extentsSize * 1.1
	modelHitbox.Color = Color3.new(1, 0, 0)
	modelHitbox.Transparency = 1
	modelHitbox.Massless = true
	modelHitbox.Name = "NPCHitbox"
	modelHitbox.CollisionGroup = "NPCHitbox"

	local weld = Instance.new("WeldConstraint", modelHitbox)
	weld.Part0 = modelHitbox
	weld.Part1 = model.PrimaryPart
	weld.Name = "HitboxWeld"

	model.Humanoid.AutoRotate = false
	model:PivotTo(CFrame.new(self.Nodes[startingNode].position))
	model.Parent = tempFolder

	local npcSpeed = math.random(minwalkspeed * 100, maxwalkspeed * 100) / 100
	local npcData : NPC = {
		model = model,
		NPCtype = npcType,
		state = "Wandering",
		active = false,
		moving = false,
		loadedAnim = model.Humanoid:LoadAnimation(ReplicatedStorage.Assets.NPCWalk),
		offset = random:NextUnitVector() * 5,
		dodgeRadius = math.random(4 * 100, 10 * 100) / 100,
		walkSpeed = npcSpeed,
		normalWalkSpeed = npcSpeed,
		currentPath = {},
		previousNode = startingNode,
		currentNode = startingNode,
		goalNode = startingNode,
		deathByCarSignal = nil,
	}

	local npcOverlap = OverlapParams.new()
	npcOverlap.FilterDescendantsInstances = {npcData.model}

	npcData.deathByCarSignal = modelHitbox.Touched:Connect(function(hit)
		if not hit:HasTag("CarHitbox") or npcData.state ~= "Wandering" then return end
		if hit.AssemblyLinearVelocity.Magnitude < 15 then return end

		local relativeSpeed = hit.AssemblyLinearVelocity - (modelHitbox.AssemblyLinearVelocity * hit.CFrame.LookVector:Dot(modelHitbox.CFrame.LookVector))
		npcData.model.Humanoid:TakeDamage(math.exp(relativeSpeed.Magnitude / 8))

		if npcData.model.Humanoid.Health <= 0 then
			self:killPedestrian(npcData, hit)

		else
			self:ragdoll(npcData)

			repeat task.wait(1) until npcData.model.PrimaryPart.AssemblyLinearVelocity.Magnitude < 5

			npcData.model.Humanoid.PlatformStand = false
			npcData.model.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
			self:unragdoll(npcData)
		end
	end)

	table.insert(self.NPCs, npcData)
	npcData.loadedAnim:Play()
end

function manager:removeNPC(model)
	for index, npcData in self.NPCs do
		if npcData.model ~= model then continue end
		npcData.model:Destroy()

		table.remove(self.NPCs, index)
		return true
	end
	return false
end

function manager:addNode(position, accessible, nodetype, connectedids, nodeid)
	for id in self.Nodes do
		if id ~= nodeid then continue end
		print("failed to add node of", accessible, "type for", nodetype, "to manager because node id", nodeid, "already exists")
		return
	end

	self.Nodes[nodeid] = {
		position = position,
		accessible = accessible,
		nodetype = nodetype,
		connectedids = connectedids,
	}
end

function manager:removeNode(nodeid)
	for id in self.Nodes do
		if id ~= nodeid then continue end
		table.remove(self.Nodes, id)
		print("removed node from manager data tree")
		return true
	end
	return false
end

function manager:updateActivity(position)
	for _, npcData in self.NPCs do
		local inRange = (npcData.model.PrimaryPart.Position - position).Magnitude <= self.streamingRadius
		if inRange and not npcData.active then
			npcData.model.Parent = Folder
			npcData.active = true

		elseif not inRange and npcData.active then
			npcData.model.Parent = tempFolder
			npcData.active = false
		end
	end
end

function manager:getHeuristic(currentPosition, goalPosition, nodetype)
	local multiplier = nodetype == "Sidewalk" and 0.5 or 1
	local distance = (currentPosition - goalPosition).Magnitude
	return distance * multiplier
end

function manager:calculatePath(pedestrian)
	local path = {}
	if pedestrian.currentNode == pedestrian.goalNode then return path end

	local bestNode = pedestrian.currentNode
	local repeats = 0
	repeat
		local lowestCost = math.huge

		for _, id in self.Nodes[bestNode].connectedids do
			local node = self.Nodes[id]
			if node.accessible ~= "Pedestrian" or id == bestNode then continue end

			local fCost = self:getHeuristic(node.position, self.Nodes[pedestrian.goalNode].position, node.nodetype)
			if fCost <= lowestCost then
				lowestCost = fCost
				bestNode = id
			end
		end

		if not bestNode then
			print("Couldn't find new path from", pedestrian.currentNode, "to", pedestrian.goalNode, "removing npc to avoid failure")
			self:removeNPC(pedestrian.model)
			return {}
		end

		table.insert(path, bestNode)
		repeats += 1
	until path[#path] == pedestrian.goalNode or repeats > #self.Nodes

	return path
end

function manager:getPlausibleNodePath(pedestrian)
	local path = {}
	local possibleNodes = {}

	local currentNode = self.Nodes[pedestrian.currentNode]
	for _, nodeid in currentNode.connectedids do
		if nodeid == pedestrian.previousNode and #currentNode.connectedids > 1 then continue end
		for _ = 1, (self.Nodes[nodeid].nodetype == "Sidewalk" and 2 or 1), 1 do
			table.insert(possibleNodes, nodeid)
		end
	end

	table.insert(path, possibleNodes[math.random(1, #possibleNodes)])
	return path
end

function movePedestrian(self, pedestrian)
	pedestrian.moving = true
	for _, nodeid in pedestrian.currentPath do
		local goalNodePosition = self.Nodes[nodeid].position --+ pedestrian.offset

		repeat
			if pedestrian.state ~= "Wandering" then break end

			local pedestrianPosition = pedestrian.model.PrimaryPart.Position
			local directionalCFrame = CFrame.lookAt(pedestrianPosition, goalNodePosition)
			local dodgeVector = Vector3.zero
			local carDodgeVector = Vector3.zero
			local addedSpeed = 0

			for _, ped in self.NPCs do
				if ped.NPCtype ~= "Pedestrian" or not ped.active or ped.model == pedestrian.model or ped.state ~= "Wandering" then continue end

				local dist = ped.model.PrimaryPart.Position - pedestrianPosition
				local distmag = dist.Magnitude
				if distmag > pedestrian.dodgeRadius then continue end

				local distlocal = directionalCFrame:VectorToObjectSpace(dist) * Vector3.xAxis
				local difference = pedestrian.dodgeRadius - distmag
				dodgeVector -= distlocal.Unit * math.clamp(difference, 0, 1) * .4
			end

			local goalPosition = goalNodePosition + directionalCFrame:VectorToWorldSpace(dodgeVector) * (pedestrianPosition - goalNodePosition).Magnitude

			pedestrian.walkSpeed = pedestrian.normalWalkSpeed + addedSpeed
			pedestrian.model.Humanoid.WalkSpeed = pedestrian.walkSpeed
			pedestrian.loadedAnim:AdjustWeight(pedestrian.walkSpeed / 25)
			pedestrian.model.PrimaryPart.TurningGyro.CFrame = CFrame.lookAt(pedestrianPosition, goalPosition)

			pedestrian.model.Humanoid:MoveTo(goalPosition)
			task.wait()
		until ((pedestrianPosition - goalNodePosition) * Vector3.new(1, 0, 1)).Magnitude <= 2 or pedestrian.state ~= "Wandering"
		if pedestrian.state ~= "Wandering" then break end

		pedestrian.previousNode = pedestrian.currentNode
		pedestrian.currentNode = nodeid
		pedestrian.offset = random:NextUnitVector() * 5
	end
	pedestrian.moving = false
end

function manager:updatePedestrian(pedestrian)
	if pedestrian.state == "Dead" then return end
	if pedestrian.currentNode == pedestrian.goalNode then
        --[[ Find new node and calculate path
        local accessibleNodes = {}

        for id, nodeData in self.Nodes do
            if nodeData.accessible ~= "Pedestrian" or id == pedestrian.currentNode then continue end
            table.insert(accessibleNodes, id)
        end

        pedestrian.goalNode = math.random(1, #accessibleNodes)
        pedestrian.currentPath = self:calculatePath(pedestrian)]]
		pedestrian.currentPath = self:getPlausibleNodePath(pedestrian)
		pedestrian.goalNode = pedestrian.currentPath[#pedestrian.currentPath]
	end

	-- Move to node
	task.spawn(movePedestrian, self, pedestrian)
end

function manager:updatePedestrians()
	for _, pedestrian in self.NPCs do
		if not pedestrian.active or pedestrian.moving or pedestrian.NPCtype ~= "Pedestrian" or pedestrian.state == "Dead" then continue end
		self:updatePedestrian(pedestrian)
	end
end

function manager:ragdoll(pedestrian)
	if pedestrian.state == "Ragdolled" then return end
	pedestrian.state = "Ragdolled"
	pedestrian.model.Humanoid:ChangeState(Enum.HumanoidStateType.Ragdoll)
	pedestrian.model.Humanoid.PlatformStand = true
	pedestrian.model.PrimaryPart.TurningGyro.MaxTorque = Vector3.zero

	local folder = Instance.new("Folder", pedestrian.model)
	folder.Name = "Hitboxes"

	for _, joint in pedestrian.model:GetDescendants() do
		if joint:IsA("BasePart") and joint.Name ~= "NPCHitbox" then
			local p = Instance.new("Part", folder)
			p.Size = joint.Size
			p.CFrame = joint.CFrame
			p.Transparency = 1
			p.CanQuery = false
			p.CanTouch = false
			p.CollisionGroup = "NPC"

			local w = Instance.new("WeldConstraint", p)
			w.Part0 = p
			w.Part1 = joint
		end

		if not joint:IsA("Motor6D") then continue end
		local socket = Instance.new("BallSocketConstraint")
		local a0, a1 = Instance.new("Attachment"), Instance.new("Attachment")
		a0.Name = "Attachment0"
		a1.Name = "Attachment1"
		a0.Parent = joint.Part0
		a1.Parent = joint.Part1
		socket.Parent = joint.Parent
		socket.Attachment0 = a0
		socket.Attachment1 = a1
		a0.CFrame = joint.C0
		a1.CFrame = joint.C1
		socket.LimitsEnabled = true
		socket.TwistLimitsEnabled = true
		socket.UpperAngle = 20
		socket.TwistLowerAngle = -35
		socket.TwistUpperAngle = 15
		socket.Name = joint.Name .. "Socket"
		joint.Enabled = false
	end
end

function manager:unragdoll(pedestrian)
	if pedestrian.state ~= "Ragdolled" then return end
	pedestrian.state = "Wandering"
	pedestrian.model.Humanoid.PlatformStand = false
	pedestrian.model.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
	pedestrian.model.PrimaryPart.TurningGyro.MaxTorque = Vector3.yAxis * gyroMaxTorque
	pedestrian.model.Hitboxes:Destroy()
	
	for _, joint in pedestrian.model:GetDescendants() do
		if not joint:IsA("Motor6D") then continue end
		local socket = joint.Parent:FindFirstChild(joint.Name .. "Socket")
		if socket then socket:Destroy() end
		joint.Enabled = true
	end
end

function manager:killPedestrian(pedestrian, hit)
	if pedestrian.state == "Dead" then return end

	local attachment = Instance.new("Attachment", pedestrian.model.PrimaryPart)
	attachment.Position = Vector3.new(math.random(-10, 10), math.random(-20, 20), math.random(-5, 5)) * .1
	attachment.Name = "BloodAttachment"

	local hitsfx = ReplicatedStorage.Assets.PedestrianHit:Clone()
	hitsfx.Parent = pedestrian.model.PrimaryPart
	hitsfx:Play()

	local Blood = ReplicatedStorage.Assets.Blood:Clone()
	Blood.Acceleration = hit.AssemblyLinearVelocity * .95 - Vector3.yAxis * 5
	Blood.Parent = attachment
	Blood:Emit(10)

	pedestrian.model.Humanoid.BreakJointsOnDeath = false
	pedestrian.model.Humanoid.Health = 0

	self:ragdoll(pedestrian)

	pedestrian.state = "Dead"
	repeat task.wait(1) until pedestrian.model.PrimaryPart.AssemblyLinearVelocity.Magnitude < 5

	self:spawnRandomPedestrians()
	self:removeNPC(pedestrian.model)
end

function manager:spawnRandomPedestrians(n)
	n = n or 1
	for _ = 1, n do
		self:addNPC(ReplicatedStorage.NPCModels["Pedestrian" .. math.random(1, #ReplicatedStorage.NPCModels:GetChildren())]:Clone(), "Pedestrian")
	end
end

return manager
