-- Services

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

-- Types

type CAR_CONFIG = {
	GEAR_RATIOS : {number},

	MAX_SPEED : number,
	TORQUE : number,
	BRAKE_TORQUE : number,
	HANDBRAKE_TORQUE : number,

	TURN_SPEED : number,
	TURN_ANGLE : number,
	TURN_DECAY : number,
	TURN_MIN_ANGLE : number,
	SW_ANGLE : number,

	DRIVETRAIN : "A" | "F" | "R",

	MAX_RPM : number,
	REDLINE_RPM : number,
	IDLE_RPM : number,
	AUTOMATIC_GEAR_CHANGE_TIME : number,
	MANUAL_GEAR_CHANGE_TIME : number,

	ENGINE_LOUDNESS : number,
	WHEEL_SCREECH_THRESHOLD : number,

	GEARS_PERCENTAGEMAX : {number},

	FRONT_WHEEL_DENSITY : number,
	FRONT_WHEEL_ELASTICITY : number,
	FRONT_WHEEL_ELASTICITY_WEIGHT : number,
	FRONT_WHEEL_FRICTION : number,
	FRONT_WHEEL_FRICTION_CURVE : {any},

	BACK_WHEEL_DENSITY : number,
	BACK_WHEEL_ELASTICITY : number,
	BACK_WHEEL_ELASTICITY_WEIGHT : number,
	BACK_WHEEL_FRICTION : number,
	BACK_WHEEL_FRICTION_CURVE : {any},
}

-- Variables

local LocalPlayer = Players.LocalPlayer
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local Modules = ReplicatedStorage:WaitForChild("Modules")

local VehiclesFolder = workspace:FindFirstChild("Vehicles")
local FloorRayParams = RaycastParams.new()
FloorRayParams.FilterDescendantsInstances = {VehiclesFolder}
FloorRayParams.IgnoreWater = true
FloorRayParams.RespectCanCollide = true
FloorRayParams.CollisionGroup = "Wheel"

local RobloxUnits = require(Modules.RobloxUnits)
local GameSettings = require(Modules.GameSettings)
local carmodule = {}
carmodule.__index = carmodule

local engineBrakingThreshold = 200

-- Runtime

function Lerp(value, goal, alpha)
	if typeof(value) == "number" then
		return value + (goal - value) * alpha

	else
		return value:Lerp(goal, alpha)
	end
end

function carmodule:SetLights(Car, lightName, active, doesSendServer)
	local Lights = Car.Misc:FindFirstChild("Lights")
	if not Lights then return end
	
	local foundLight = Lights:FindFirstChild(lightName)
	if not foundLight then return end
	
	if foundLight:GetAttribute("Active") == active then return end
	foundLight:SetAttribute("Active", active)
	
	if doesSendServer ~= false then Remotes.CarLights:FireServer(lightName, active) end
	for _, obj in foundLight:GetDescendants() do
		if obj:IsA("BasePart") then
			obj.Material = active and Enum.Material.Neon or Enum.Material.SmoothPlastic

		elseif obj:IsA("SpotLight") or obj:IsA("PointLight") or obj:IsA("SurfaceLight") then
			obj.Enabled = active
		end
	end
end

function carmodule:Backfire(Car, doesSendServer)
	if doesSendServer ~= false then Remotes.CarBackfire:FireServer() end

	local BackfireModel = Car.Misc:FindFirstChild("Backfire")
	if BackfireModel then
		for _, obj in BackfireModel:GetChildren() do
			local backfireSounds = {}
			for _, sound in obj:GetDescendants() do
				if not sound:IsA("Sound") then continue end

				table.insert(backfireSounds, sound)
			end

			local rng = math.random(1, #backfireSounds)
			backfireSounds[rng].Volume = .1 * (GameSettings["Backfire Volume"] / 100)
			backfireSounds[rng]:Play()

			for _, particle in obj:GetDescendants() do
				if particle:IsA("ParticleEmitter") then
					particle:Emit(5)
				end
			end
		end
	end
end

function carmodule.init(Car)
	local Base = Car.Base
	local Decoration = Car.Decoration
	local Misc = Car.Misc
	local Prefabs = Car.Prefabs

	local self = setmetatable({}, carmodule)

	self.config = require(Car.Config) :: CAR_CONFIG
	self.config.AUTOMATIC = not GameSettings["Manual Transmission"]

	self.Vehicle = Car
	self.oldUI = nil
	self.oldIKL = nil
	self.oldIKR = nil

	self.currentCamera = 1
	self.currentGear = 1
	self.currentSteer = 0
	self.currentRPM = 0
	self.previousRPM = 0

	self.gas = 0
	self.brake = 0
	self.steer = 0
	self.handbrake = false
	self.parked = false
	self.isFuelCut = false

	self.UI = ReplicatedStorage.Assets.CarHUD:Clone()
	self.UI.Parent = LocalPlayer.PlayerGui

	self.UI_START_ROTATION = -45
	self.UI_END_ROTATION = 225
	self.UI_RPM_ITEMS = math.ceil(self.config.MAX_RPM / 1000)

	for i = 1, self.UI_RPM_ITEMS, 1 do
		local new = self.UI.Main.ShowRPM0:Clone()
		new.Name = "ShowRPM" .. i
		new.Label.Text = i
		new.Rotation = self.UI_START_ROTATION + (self.UI_END_ROTATION - self.UI_START_ROTATION) * (i / self.UI_RPM_ITEMS)
		new.Label.Rotation = -new.Rotation
		new.Parent = self.UI.Main
	end

	self.runtime = RunService.Heartbeat:Connect(function(delta)
		local success, errorMessage = pcall(function()
			self.config.AUTOMATIC = not GameSettings["Manual Transmission"]

			local delta60 = delta * 60

			local directionalSpeed = Base.Base.CFrame:VectorToObjectSpace(Base.Base.AssemblyLinearVelocity)
			local currentVelocity = directionalSpeed

			local currentGearRatio = self.config.GEAR_RATIOS[self.currentGear == -1 and 1 or self.currentGear + 1]
			local gearMaxSpeed = self.config.MAX_SPEED / math.abs(currentGearRatio)
			local gearTorque = RobloxUnits.convertUnits(self.config.TORQUE, "NM_torque", "rbx_torque") * math.max(math.abs(currentGearRatio), .1)

			local percentageToMax = math.clamp(-currentVelocity.Z / gearMaxSpeed, 0, 1)
			local percentageToActualMax = math.clamp(-currentVelocity.Z / self.config.MAX_SPEED, 0, 1)

			local averageWheelRotation = 0
			local averageSlip = 0
			local slipDifferences = {}

			self.currentOnGround = false

			for _, cylindrical in Base.Wheels.WheelCylindricals:GetChildren() do
				local correspondingWheel = Base.Wheels:FindFirstChild(cylindrical.Name)

				local objectRotationalSpeed = correspondingWheel.CFrame:VectorToObjectSpace(correspondingWheel.AssemblyAngularVelocity)
				local rotation = math.abs(objectRotationalSpeed.X * (correspondingWheel.Size.Y/2))

				local ray = workspace:Raycast(correspondingWheel.Position, -Base.Base.CFrame.UpVector * (correspondingWheel.Size.Y / 2 + .1), FloorRayParams)
				local onGround = ray and ray.Instance
				if onGround then 		self.currentOnGround = true end

				local slipDifference = math.abs(correspondingWheel.AssemblyLinearVelocity.Magnitude - rotation)
				if slipDifference <= self.config.WHEEL_SCREECH_THRESHOLD then slipDifference = 0 end
				averageSlip += onGround and slipDifference * .25 or 0
				slipDifferences[correspondingWheel] = onGround and slipDifference or 0

				local t = string.sub(cylindrical.Name, 1, 1)
				if self.parked and t == "R" then
					cylindrical.AngularVelocity = 0
					cylindrical.MotorMaxTorque = self.config.HANDBRAKE_TORQUE
					cylindrical.AngularActuatorType = Enum.ActuatorType.Motor

				elseif self.currentGear == 0 or (self.handbrake and t == "R") then
					cylindrical.AngularVelocity = 0
					cylindrical.MotorMaxTorque = self.handbrake and self.config.HANDBRAKE_TORQUE or 0
					cylindrical.AngularActuatorType = Enum.ActuatorType.Motor

				else
					local gas = self.gas
					local engineBraking = 0

					if self.isFuelCut then
						gas = 0
						engineBraking = .1
					end

					local brake = self.brake + engineBraking
					local maxAngularSpeed = gearMaxSpeed / correspondingWheel.Size.Y * 2
					local scalar = 1
					if self.currentGear > 0 then
						scalar = 1 - brake
					end

					if self.config.AUTOMATIC then
						cylindrical.AngularVelocity = (brake - gas) * maxAngularSpeed * scalar

					else
						cylindrical.AngularVelocity = -gas * maxAngularSpeed * scalar * math.sign(self.currentGear)
					end

					if cylindrical.AngularVelocity * math.sign(self.currentGear) >= 0 or (self.config.DRIVETRAIN == "A" or t == self.config.DRIVETRAIN) then
						if brake == 0 and (self.currentGear > 0 or (self.currentGear < 0 and not self.config.AUTOMATIC)) then
							cylindrical.MotorMaxTorque = gearTorque * gas
						elseif brake == 1 and self.currentGear < 0 then
							cylindrical.MotorMaxTorque = gearTorque * brake
						else
							cylindrical.MotorMaxTorque = self.config.BRAKE_TORQUE * brake
						end
						cylindrical.AngularActuatorType = Enum.ActuatorType.Motor

					else
						cylindrical.MotorMaxTorque = 0
						cylindrical.AngularActuatorType = Enum.ActuatorType.None
					end
				end

				averageWheelRotation = math.max(averageWheelRotation, math.abs(rotation))
			end

			for _, wheel in Base.Wheels:GetChildren() do
				if not wheel:IsA("BasePart") then continue end
				local slipValue = (slipDifferences[wheel] + averageSlip) / 2
				local newValue = self.config.FRONT_WHEEL_FRICTION_CURVE:GetValue(math.clamp(slipValue/50, 0, 1))

				local t = string.sub(wheel.Name, 1, 1)
				if t == "F" then
					wheel.CustomPhysicalProperties = PhysicalProperties.new(self.config.FRONT_WHEEL_DENSITY, self.config.FRONT_WHEEL_FRICTION * newValue, self.config.FRONT_WHEEL_ELASTICITY, 100, self.config.FRONT_WHEEL_ELASTICITY_WEIGHT)
				else
					wheel.CustomPhysicalProperties = PhysicalProperties.new(self.config.BACK_WHEEL_DENSITY, self.config.BACK_WHEEL_FRICTION * newValue, self.config.BACK_WHEEL_ELASTICITY, 100, self.config.BACK_WHEEL_ELASTICITY_WEIGHT)
				end
			end

			if self.currentGear ~= 0 then
				self.previousRPM = self.currentRPM
				self.currentRPM = math.clamp(self.config.IDLE_RPM + (math.abs(averageWheelRotation * currentGearRatio) / self.config.MAX_SPEED) * (self.config.REDLINE_RPM - self.config.IDLE_RPM), 0, self.config.MAX_RPM)

				Base.Engine.EngineSound.Playing = true
				Base.Engine.EngineSound.PlaybackSpeed = Lerp(Base.Engine.EngineSound.PlaybackSpeed, self.currentRPM / self.config.REDLINE_RPM + .3, .5 * delta60)
				Base.Engine.EngineSound.Volume = Lerp(Base.Engine.EngineSound.Volume, (self.currentRPM / self.config.REDLINE_RPM) * self.config.ENGINE_LOUDNESS * (GameSettings["Engine Volume"] / 100), .4 * delta60)

				Base.Engine.EngineSound.PitchShift.Octave = Lerp(Base.Engine.EngineSound.PitchShift.Octave, (self.currentRPM / self.config.REDLINE_RPM * .6) + .5, .6 * delta60)
				Base.Engine.EngineSound.DistortionEffect.Level = Lerp(Base.Engine.EngineSound.DistortionEffect.Level, (self.currentRPM / self.config.REDLINE_RPM * .6), .4 * delta60)

				if self.currentRPM >= self.config.REDLINE_RPM then
					self.isFuelCut = true

				elseif self.currentRPM <= self.config.REDLINE_RPM - engineBrakingThreshold then
					self.isFuelCut = false
				end
			end

			local angle = -math.rad(self.config.TURN_ANGLE * self.currentSteer) / (-self.config.TURN_MIN_ANGLE / (math.abs(currentVelocity.Z) / self.config.TURN_DECAY + 1) + self.config.TURN_MIN_ANGLE + 1)
			Base.Base.FL.CFrame = Base.Base.FL:GetAttribute("originalCFrame") * CFrame.Angles(angle, 0, 0)
			Base.Base.FR.CFrame = Base.Base.FR:GetAttribute("originalCFrame") * CFrame.Angles(angle, 0, 0)

			self.currentSteer = math.clamp(self.currentSteer + ((self.config.TURN_SPEED / self.config.TURN_ANGLE) * delta * math.sign(self.steer - self.currentSteer)), -1, 1)
			if self.currentSteer <= self.steer + (self.config.TURN_SPEED / self.config.TURN_ANGLE) * delta * 2 and self.currentSteer >= self.steer - (self.config.TURN_SPEED / self.config.TURN_ANGLE) * delta * 2 then self.currentSteer = self.steer end

			if -directionalSpeed.Z > 1 then
				carmodule:SetLights(Car, "B", true)
				carmodule:SetLights(Car, "F", true)
				carmodule:SetLights(Car, "Rev", false)
				carmodule:SetLights(Car, "Br", self.brake >= .1)

			elseif -directionalSpeed.Z < -1 then
				carmodule:SetLights(Car, "B", false)
				carmodule:SetLights(Car, "F", false)
				carmodule:SetLights(Car, "Rev", true)
				carmodule:SetLights(Car, "Br", false)

			else
				if self.currentGear >= 1 then
					carmodule:SetLights(Car, "B", true)
					carmodule:SetLights(Car, "F", true)
					carmodule:SetLights(Car, "Rev", false)

				elseif self.currentGear == 0 then
					carmodule:SetLights(Car, "B", false)
					carmodule:SetLights(Car, "F", false)
					carmodule:SetLights(Car, "Rev", false)
					carmodule:SetLights(Car, "Br", false)

				elseif self.currentGear == -1 then
					carmodule:SetLights(Car, "B", false)
					carmodule:SetLights(Car, "F", false)
					carmodule:SetLights(Car, "Rev", true)
					carmodule:SetLights(Car, "Br", false)
				end
			end

			local SWAttachment = Base.Base:FindFirstChild("SWAttachment")
			if SWAttachment then SWAttachment.CFrame = SWAttachment.CFrame:Lerp(SWAttachment:GetAttribute("originalCFrame") * CFrame.Angles(0, -angle / self.config.TURN_ANGLE * self.config.SW_ANGLE, 0), .1) end

			if self.config.AUTOMATIC and self.currentGear ~= 0 then
				local newGear = nil
				local amountBackfire = 0

				if (self.brake <= .1 or self.handbrake) and self.gas >= .1 and self.currentGear == -1 then
					newGear = 1

				else
					if percentageToMax >= .97 and self.currentGear < #self.config.GEAR_RATIOS-1 and self.currentGear ~= -1 and self.gas >= .1 and self.brake <= .1 then
						newGear = math.clamp(self.currentGear + 1, 1, #self.config.GEAR_RATIOS - 1)
						amountBackfire = math.random(1, 100) <= 50 and (math.random(1, 100) <= 50 and 2 or 1) or 0

					elseif self.gas - self.brake <= .1 and self.currentGear > 1 and self.currentGear ~= -1 and percentageToActualMax <= self.config.GEARS_PERCENTAGEMAX[self.currentGear - 1] then
						newGear = math.clamp(self.currentGear - 1, 1, #self.config.GEAR_RATIOS - 1)

					elseif percentageToMax <= .2 and self.currentGear == 1 and self.brake >= .1 and self.gas <= .1 then
						newGear = -1
					end
				end

				if newGear and self.currentGear ~= newGear then
					task.spawn(function()
						for i = 1, amountBackfire, 1 do
							carmodule:Backfire(Car)
							task.wait(.2)
						end
					end)

					task.defer(function()
						self.currentGear = 0
						task.wait(self.config.AUTOMATIC_GEAR_CHANGE_TIME)

						self.currentGear = newGear
					end)
				end
			end

			self.currentSpeed = math.abs(directionalSpeed.Z)
			self.avgSlip = averageSlip
		end)
		if not success then
			print("Disconnecting car from client", self.Vehicle.Name)
			self:remove()
		end
	end)

	print("init car client", self.Vehicle.Name)
	return self
end

function carmodule.initVisuals(Car)
	local self = setmetatable({}, carmodule)

	self.config = require(Car:WaitForChild("Config"))
	self.Vehicle = Car

	self.runtime = RunService.Heartbeat:Connect(function(delta)
		local success, errorMessage = pcall(function()
			for _, wheel in self.Vehicle.Base.Wheels:GetChildren() do
				if not wheel:IsA("BasePart") then continue end

				local objectRotationalSpeed = wheel.CFrame:VectorToObjectSpace(wheel.AssemblyAngularVelocity)
				local rotation = math.abs(objectRotationalSpeed.X * (wheel.Size.Y/2))

				local ray = workspace:Raycast(wheel.Position, -self.Vehicle.Base.Base.CFrame.UpVector * (wheel.Size.Y / 2 + .1), FloorRayParams)
				local onGround = ray and ray.Instance

				local slipDifference = math.abs(wheel.AssemblyLinearVelocity.Magnitude - rotation)
				if slipDifference <= self.config.WHEEL_SCREECH_THRESHOLD then slipDifference = 0 end

				local screechAudio = wheel:FindFirstChild("Screech")
				if screechAudio then
					screechAudio.Playing = true
					screechAudio.Volume = screechAudio.Volume + ((onGround and math.clamp(slipDifference / 100, 0, .2) * (GameSettings["Tire Screech Volume"] / 100) or 0) - screechAudio.Volume) * (6 * delta)
				end

				local smoke = wheel:FindFirstChild("TireSmoke")
				if smoke then
					smoke.Enabled = true
					smoke.Rate = onGround and math.clamp(math.floor(slipDifference) * 2, 0, 10) or 0
				end

				local Fixed = wheel:FindFirstChild("Fixed")
				if Fixed and Fixed.PrimaryPart then
					local trail = Fixed.PrimaryPart:FindFirstChild("Trail")
					if trail then
						trail.Enabled = onGround and slipDifference ~= 0 or false
					end
				end
			end
		end)
		if not success then
			print("Disconnecting car visuals from", self.Vehicle.Name)
			self.runtime:Disconnect()
		end
	end)

	return self
end

function carmodule:remove()
	if self.Vehicle and self.Vehicle:FindFirstChild("Base") and self.Vehicle.Base:FindFirstChild("Base") and self.Vehicle.Base.Base:FindFirstChild("Engine") then 
		self.Vehicle.Base.Engine.EngineSound:Stop()
	end
	self.UI:Destroy()
	self.runtime:Disconnect()
	table.clear(self)
end

function carmodule:removeVisuals()
	self.runtime:Disconnect()
	table.clear(self)
end

return carmodule
